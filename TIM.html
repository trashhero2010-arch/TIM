
<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>俄罗斯方块（带计分：每行 +1000 分）</title>
  <style>
    :root { --cell: 28px; --gap: 2px; --bg: #0f1220; --panel: #161a2b; --text: #e8eaf6; }
    * { box-sizing: border-box; }
    body { margin: 0; font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial; background: var(--bg); color: var(--text); }
    .wrap { max-width: 980px; margin: 24px auto; padding: 12px; display: grid; grid-template-columns: auto 280px; gap: 16px; }
    .board { background: #0b0e1a; padding: 12px; border-radius: 16px; box-shadow: 0 10px 30px rgba(0,0,0,.35) inset, 0 10px 30px rgba(0,0,0,.35); }
    .grid { display: grid; grid-template-columns: repeat(10, var(--cell)); grid-auto-rows: var(--cell); gap: var(--gap); }
    .cell { width: var(--cell); height: var(--cell); background: #1b2342; border-radius: 6px; }
    /* 7 种方块的色块 */
    .cI { background: #39d0ff; }
    .cJ { background: #4a67ff; }
    .cL { background: #ff9f2d; }
    .cO { background: #ffd633; }
    .cS { background: #3bd37f; }
    .cT { background: #b96bff; }
    .cZ { background: #ff5a6b; }

    .sidebar { background: var(--panel); padding: 16px; border-radius: 16px; box-shadow: 0 10px 30px rgba(0,0,0,.35); display: flex; flex-direction: column; gap: 16px; }
    h1 { font-size: 20px; margin: 0 0 8px; letter-spacing: .5px; }
    .stat { display: grid; grid-template-columns: 1fr auto; gap: 6px 10px; align-items: center; }
    .badge { background: #0b0e1a; padding: 8px 10px; border-radius: 10px; text-align: right; font-variant-numeric: tabular-nums; }
    .btns { display: grid; grid-template-columns: repeat(2, 1fr); gap: 10px; }
    button { cursor: pointer; padding: 10px 12px; border-radius: 12px; border: none; background: #2a3568; color: var(--text); font-weight: 700; letter-spacing: .3px; }
    button:hover { filter: brightness(1.15); }
    .next { display: grid; grid-template-columns: repeat(4, var(--cell)); grid-auto-rows: var(--cell); gap: var(--gap); background: #0b0e1a; padding: 8px; border-radius: 12px; width: calc(var(--cell)*4 + var(--gap)*3 + 16px); }
    .hint { font-size: 12px; opacity: .8; line-height: 1.5; }
    .footer { font-size: 12px; opacity: .6; text-align: center; }
    .overlay { position: absolute; inset: 0; display: none; align-items: center; justify-content: center; color: #fff; font-weight: 800; backdrop-filter: blur(2px); }
    .overlay.show { display: flex; }
    .status { background: rgba(0,0,0,.5); padding: 10px 14px; border-radius: 12px; }

    @media (max-width: 860px){ .wrap{ grid-template-columns: 1fr; } .sidebar{ order: -1; } }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="board">
      <h1>俄罗斯方块</h1>
      <div id="stage" class="grid"></div>
      <div id="overlay" class="overlay"><div class="status" id="statusText">游戏结束</div></div>
    </div>

    <aside class="sidebar">
      <div>
        <h1>计分（每消一行 +1000 分）</h1>
        <div class="stat">
          <div>分数</div><div class="badge" id="score">0</div>
          <div>最高</div><div class="badge" id="hiscore">0</div>
          <div>等级</div><div class="badge" id="level">1</div>
          <div>行数</div><div class="badge" id="lines">0</div>
        </div>
      </div>

      <div>
        <h1>下一块</h1>
        <div id="next" class="next"></div>
      </div>

      <div class="btns">
        <button id="startBtn">开始/重开</button>
        <button id="pauseBtn">暂停/继续</button>
      </div>

      <div class="hint">
        操作：← → 移动，↑ 旋转，↓ 快速下落，空格硬降。<br>
        规则：每消除 <b>1 行</b> 加 <b>1000</b> 分；多行叠加。
      </div>
      <div class="footer">只用原生 HTML/CSS/JS</div>
    </aside>
  </div>

  <script>
  // === 配置 ===
  const COLS = 10, ROWS = 20;
  const TICK_BASE = 700; // 基础下落间隔（毫秒）
  const SPEEDUP_EVERY = 10; // 每消多少行升级
  const SCORE_PER_LINE = 1000; // 每行 +1000 分

  const SHAPES = {
    I: [
      [[0,1],[1,1],[2,1],[3,1]],
      [[2,0],[2,1],[2,2],[2,3]],
      [[0,2],[1,2],[2,2],[3,2]],
      [[1,0],[1,1],[1,2],[1,3]],
    ],
    J: [
      [[0,0],[0,1],[1,1],[2,1]],
      [[1,0],[2,0],[1,1],[1,2]],
      [[0,1],[1,1],[2,1],[2,2]],
      [[1,0],[1,1],[0,2],[1,2]],
    ],
    L: [
      [[2,0],[0,1],[1,1],[2,1]],
      [[1,0],[1,1],[1,2],[2,2]],
      [[0,1],[1,1],[2,1],[0,2]],
      [[0,0],[1,0],[1,1],[1,2]],
    ],
    O: [
      [[1,0],[2,0],[1,1],[2,1]],
      [[1,0],[2,0],[1,1],[2,1]],
      [[1,0],[2,0],[1,1],[2,1]],
      [[1,0],[2,0],[1,1],[2,1]],
    ],
    S: [
      [[1,0],[2,0],[0,1],[1,1]],
      [[1,0],[1,1],[2,1],[2,2]],
      [[1,1],[2,1],[0,2],[1,2]],
      [[0,0],[0,1],[1,1],[1,2]],
    ],
    T: [
      [[1,0],[0,1],[1,1],[2,1]],
      [[1,0],[1,1],[2,1],[1,2]],
      [[0,1],[1,1],[2,1],[1,2]],
      [[1,0],[0,1],[1,1],[1,2]],
    ],
    Z: [
      [[0,0],[1,0],[1,1],[2,1]],
      [[2,0],[1,1],[2,1],[1,2]],
      [[0,1],[1,1],[1,2],[2,2]],
      [[1,0],[0,1],[1,1],[0,2]],
    ]
  };
  const TYPES = Object.keys(SHAPES);

  // === 状态 ===
  let board, curr, next, tickId = null, paused = false, over = false;
  let score = 0, lines = 0, level = 1;

  // === DOM ===
  const stage = document.getElementById('stage');
  const nextView = document.getElementById('next');
  const scoreEl = document.getElementById('score');
  const linesEl = document.getElementById('lines');
  const levelEl = document.getElementById('level');
  const hiscoreEl = document.getElementById('hiscore');
  const overlay = document.getElementById('overlay');
  const statusText = document.getElementById('statusText');

  const startBtn = document.getElementById('startBtn');
  const pauseBtn = document.getElementById('pauseBtn');

  // === 初始化网格 ===
  function buildGrid(container, cols, rows){
    container.innerHTML = '';
    const frag = document.createDocumentFragment();
    for(let r=0;r<rows;r++){
      for(let c=0;c<cols;c++){
        const div = document.createElement('div');
        div.className = 'cell';
        frag.appendChild(div);
      }
    }
    container.appendChild(frag);
  }

  function idx(c,r){ return r*COLS + c; }

  function reset(){
    board = new Array(COLS*ROWS).fill(null);
    score = 0; lines = 0; level = 1; over = false; paused = false;
    updateStat();
    overlay.classList.remove('show');
    curr = makePiece();
    next = makePiece();
    draw();
    drawNext();
    restartTick();
  }

  function makePiece(){
    const t = TYPES[(Math.random()*TYPES.length)|0];
    return { t, r:0, x:3, y:0 };
  }

  function cellsOf(p){ return SHAPES[p.t][p.r]; }

  function canMove(nx, ny, nr = curr.r){
    const cells = SHAPES[curr.t][nr];
    for(const [dx,dy] of cells){
      const x = nx + dx, y = ny + dy;
      if(x<0||x>=COLS||y<0||y>=ROWS) return false;
      if(board[idx(x,y)]) return false;
    }
    return true;
  }

  function merge(){
    for(const [dx,dy] of cellsOf(curr)){
      const x = curr.x + dx, y = curr.y + dy;
      board[idx(x,y)] = curr.t;
    }
  }

  function clearLines(){
    let cleared = 0;
    for(let r=ROWS-1;r>=0;r--){
      let full = true;
      for(let c=0;c<COLS;c++) if(!board[idx(c,r)]){ full=false; break; }
      if(full){
        cleared++;
        for(let y=r;y>0;y--){
          for(let c=0;c<COLS;c++) board[idx(c,y)] = board[idx(c,y-1)];
        }
        for(let c=0;c<COLS;c++) board[idx(c,0)] = null;
        r++; // 重新检查该行（下移后）
      }
    }
    if(cleared){
      score += SCORE_PER_LINE * cleared; // 每行 +1000
      lines += cleared;
      level = Math.floor(lines / SPEEDUP_EVERY) + 1;
      updateStat();
      restartTick();
    }
  }

  function updateStat(){
    scoreEl.textContent = score;
    linesEl.textContent = lines;
    levelEl.textContent = level;
    const hi = Math.max(+localStorage.getItem('tetris_hi')||0, score);
    localStorage.setItem('tetris_hi', hi);
    hiscoreEl.textContent = hi;
  }

  function draw(){
    const cells = stage.children;
    for(let i=0;i<cells.length;i++) cells[i].className = 'cell';
    // 画棋盘
    for(let r=0;r<ROWS;r++){
      for(let c=0;c<COLS;c++){
        const v = board[idx(c,r)];
        if(v) cells[idx(c,r)].classList.add('c'+v);
      }
    }
    // 画当前块（浮动）
    for(const [dx,dy] of cellsOf(curr)){
      const x = curr.x + dx, y = curr.y + dy;
      if(y>=0){
        cells[idx(x,y)].classList.add('c'+curr.t);
      }
    }
  }

  function drawNext(){
    buildGrid(nextView, 4, 4);
    const cells = nextView.children;
    for(const [dx,dy] of SHAPES[next.t][0]){
      const x = dx, y = dy;
      const i = y*4 + x;
      if(cells[i]) cells[i].classList.add('c'+next.t);
    }
  }

  function tick(){
    if(over || paused) return;
    if(canMove(curr.x, curr.y+1)){
      curr.y++;
    }else{
      merge();
      clearLines();
      curr = next; next = makePiece();
      drawNext();
      if(!canMove(curr.x, curr.y)){
        over = true;
        stopTick();
        statusText.textContent = '游戏结束 - 分数 '+score;
        overlay.classList.add('show');
      }
    }
    draw();
  }

  function restartTick(){
    stopTick();
    const delay = Math.max(120, TICK_BASE - (level-1)*70);
    tickId = setInterval(tick, delay);
  }
  function stopTick(){ if(tickId){ clearInterval(tickId); tickId = null; } }

  // === 控制 ===
  document.addEventListener('keydown', e=>{
    if(over) return;
    if(e.key === 'ArrowLeft'){
      if(canMove(curr.x-1, curr.y)) curr.x--;
    }else if(e.key === 'ArrowRight'){
      if(canMove(curr.x+1, curr.y)) curr.x++;
    }else if(e.key === 'ArrowDown'){
      if(canMove(curr.x, curr.y+1)) curr.y++;
    }else if(e.key === 'ArrowUp'){
      const nr = (curr.r+1)%4; if(canMove(curr.x, curr.y, nr)) curr.r = nr;
    }else if(e.code === 'Space'){
      // 硬降
      while(canMove(curr.x, curr.y+1)) curr.y++;
      tick();
    }else{ return; }
    e.preventDefault();
    draw();
  });

  startBtn.onclick = ()=> reset();
  pauseBtn.onclick = ()=>{ if(over) return; paused = !paused; if(!paused) restartTick(); else stopTick(); };

  // 初始构建
  buildGrid(stage, COLS, ROWS);
  buildGrid(nextView, 4, 4);
  reset();
  </script>
</body>
</html>




















